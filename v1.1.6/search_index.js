var documenterSearchIndex = {"docs":
[{"location":"derivations/#Derivations","page":"Derivations","title":"Derivations","text":"","category":"section"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"Here we will derive properties of correlation functions in imaginary time and their spectral functions. If you find an error in this page please report an issue via github or email James Neuhaus. ","category":"page"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"Conventions: hbar=1, for pmmp top signs are for bosonic correlations, bottom signs fermionic","category":"page"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"Causal Matsubara correlation functions are defined such that for operators hatAhatB the correlation function is ","category":"page"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"C_AB(tau -tau)=-langle T_tauA(tau)B(tau)rangle=-Theta(tau-tau)langle A(tau)B(tau)rangle mp Theta(tau-tau)langle B(tau)A(tau)rangle ","category":"page"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"By using translational symmetry we can set tau=0 which we will do going forward.","category":"page"},{"location":"derivations/#Periodicity","page":"Derivations","title":"Periodicity","text":"","category":"section"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"Starting from tau  0 we have","category":"page"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"beginalign*\nC_ABleft(tau0right)=-langle Aleft(tauright)Bleft(0right)rangle=  -frac1ZTrlefte^-beta He^tau HAe^-tau HBright\n=  -frac1ZTrleftBe^-beta He^tau HAe^-tau Hright\n=  -frac1ZTrleftBe^-beta He^tau HAe^-tau Hleft(e^beta He^-beta Hright)right\n=  -frac1ZTrlefte^-beta HBe^-beta He^tau HAe^-tau He^beta Hright\n=  -frac1ZTrlefte^-beta HBe^left(tau-betaright)HAe^-left(tau-betaright)Hright\n=  -langle Bleft(0right)Aleft(tau-betaright)rangle\n=  pmlangle T_tauAleft(tau-betaright)Bleft(0right)rangle\n=  pm C_ABleft(tau-betaright)\nendalign*","category":"page"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"Thus, correlation functions take on the patterns:","category":"page"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"(Image: Cristophe Berthod, https://giamarchi.unige.ch/wp-content/php\\_code/people/christophe.berthod/pdf/Many-body.pdf) Cristophe Berthod","category":"page"},{"location":"derivations/#Reflection-Symmetry","page":"Derivations","title":"Reflection Symmetry","text":"","category":"section"},{"location":"derivations/#Correlation-Functions","page":"Derivations","title":"Correlation Functions","text":"","category":"section"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"Let us look at correlation functions with the operator order flipped","category":"page"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"beginalign*\nC_BAleft(tauright)=  -Thetaleft(tauright)leftlangle Bleft(tauright)Aleft(0right)rightrangle mpThetaleft(-tauright)leftlangle Aleft(0right)Bleft(tauright)rightrangle \n=  -fracThetaleft(tauright)ZTrlefte^-beta He^tau HBe^-tau HArightmpfracThetaleft(-tauright)ZTrlefte^-beta HAe^tau HBe^-tau Hright\n=  -fracThetaleft(tauright)ZTrlefte^-beta He^beta He^-tau HAe^-beta He^tau HBrightmpfracThetaleft(-tauright)ZTrlefte^-beta HAe^tau He^beta He^-beta HBe^-tau Hright\n=  -fracThetaleft(tauright)ZTrlefte^-beta He^beta He^-tau HAe^-beta He^tau HBrightmpfracThetaleft(-tauright)ZTrlefte^-beta HBe^-tau He^-beta HAe^tau He^beta Hright\n=  -fracThetaleft(tauright)ZTrlefte^-beta He^left(beta-tauright)HAe^-left(beta-tauright)He^tau HBrightmpfracThetaleft(-tauright)ZTrlefte^-beta HBe^-left(beta+tauright)HAe^left(beta+tauright)Hright\n=  -Thetaleft(tauright)leftlangle Aleft(beta-tauright)Bleft(0right)rightrangle mpThetaleft(-tauright)leftlangle Bleft(-beta-tauright)Aleft(0right)rightrangle \n=  pm C_ABleft(beta-tauright)\nendalign*","category":"page"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"It follows that in the case where the two operators are the same, B=A, this expression becomes C_AAleft(tauright)=pm C_AAleft(beta-tauright). Thus, a symmetrized/antisymmetrized kernel is needed.","category":"page"},{"location":"derivations/#Spectral-Functions","page":"Derivations","title":"Spectral Functions","text":"","category":"section"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"We define our spectral function as","category":"page"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"beginalign*\nrho_ABleft(omegaright)=  frac2piZleft(1mp e^-betaomegaright)sum_nme^-beta E_nleftlangle mlefthatArightnrightrangle leftlangle nlefthatBrightmrightrangle deltaleft(omega+E_m-E_nright)\nendalign*","category":"page"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"We will swap indices and then take omegarightarrow -omega","category":"page"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"beginalign*\nrho_ABleft(omegaright)=  frac2piZleft(1mp e^-betaomegaright)sum_nme^-beta E_nleftlangle mlefthatArightnrightrangle leftlangle nlefthatBrightmrightrangle deltaleft(omega+E_m-E_nright)\n=  -frac2piZleft(1mp e^-betaomegaright)sum_nme^-beta E_mleftlangle nlefthatBrightmrightrangle leftlangle mlefthatArightnrightrangle deltaleft(omega+E_n-E_mright)\n=  -rho_BAleft(-omegaright)\nendalign*","category":"page"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"For both fermions and bosons we pick up a minus sign for two different reasons: bosons because of the inverted Bose factor 1-e^-betaomegarightarrow e^-betaomega-1 and the fermion case's sign flips from the operator order flip. ","category":"page"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"In the case of A=B we get rho(omega)=-rho(-omega)","category":"page"},{"location":"derivations/#Kernels-for-\\tau\\rightarrow\\omega","page":"Derivations","title":"Kernels for taurightarrowomega","text":"","category":"section"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"Spectral functions are defined in such a way as to reflect what is measured in experiment. For example, let's look at the correlation function which is also the electron Green's function","category":"page"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"beginalign*\nG_alphabetaleft(tauright)=  -leftlangle T_taua_alphaleft(tauright)a_beta^daggerleft(0right)rightrangle \nendalign*","category":"page"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"This relates back to the spectral function for the electron occupation energies through the relation","category":"page"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"beginalign*\nGleft(mathbfksigmatau0right)=  -leftlangle c_mathbfksigmaleft(tauright)c_mathbfksigma^daggerleft(0right)rightrangle \n=  -frac1Zsum_nleftlangle nlefte^-beta He^tau Hc_mathbfksigmae^-tau Hc_mathbfksigma^daggerrightnrightrangle \n=  -frac1Zsum_ne^-beta E_ne^tau E_nleftlangle nleftc_mathbfksigmae^-tau Hc_mathbfksigma^daggerrightnrightrangle \n=  -frac1Zsum_mne^-beta E_ne^tauleft(E_n-E_mright)leftlangle nleftc_mathbfksigmarightmrightrangle leftlangle mleftc_mathbfksigma^daggerrightnrightrangle \n=  -frac1Zsum_mne^-beta E_ne^tauleft(E_n-E_mright)leftleftlangle mleftc_mathbfksigma^daggerrightnrightrangle right^2\n=  -int_-infty^inftyfracdomegapifrace^-omegatau1+e^-betaomegaIm Gleft(mathbfksigmaomegaright)\n=  int_-infty^infty domega frace^-omegatau1+e^-betaomegaAleft(mathbfksigmaomegaright)\nendalign*","category":"page"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"This gives us the fermionic kernel of frace^-omegatau1+e^-betaomega. Doing the same treatment for antisymmetric fermionic correlations, bosonic correlations, and symmetric bosonic correlations we get the following kernels:","category":"page"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"beginalign*\nK_fermionleft(omegatauright)=  frace^-tauomega1+e^-betaomega\nK_fermionantisymleft(omegatauright)=  frac12frace^-tauomega-e^-left(beta-tauright)omega1+e^-betaomega\nK_bosonasymleft(omegatauright)=  frace^-tauomega1-e^-betaomega\nK_bosonsymleft(omegatauright)=  frac12frace^-tauomega+e^-left(beta-tauright)1-e^-betaomega\nendalign*","category":"page"},{"location":"derivations/#Bosonic-Kernel-Modifications-for-AC-methods","page":"Derivations","title":"Bosonic Kernel Modifications for AC methods","text":"","category":"section"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"For kernel functions odd about omega=0 most AC codes will pull a factor of omega into the kernel. This makes the kernel analytic on the entire omega line but AC will give you fracrho(omega)omega. Some codes will return this value. DEAC.jl handles this in the back end and reports only rho(omega).","category":"page"},{"location":"derivations/#Normalization","page":"Derivations","title":"Normalization","text":"","category":"section"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"For the fermionic non-symmetric case it is simple to tell the zeroth moment of the spectral function","category":"page"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"beginalign*\nC_ABleft(0right)+C_ABleft(betaright)=  int domega Aleft(omegaright)frace^-0omega+e^-betaomega1+e^-betaomega\nC_ABleft(0right)+C_ABleft(betaright)=  int domega Aleft(omegaright)\nendalign*","category":"page"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"For any others there is no obvious way to derive the zeroth moment. ","category":"page"},{"location":"examples/SmoQyDQMC/#Example-2:-Load-from-SmoQyDQMC-and-run-SmoQyDEAC","page":"Example 2: Load from SmoQyDQMC and run SmoQyDEAC","title":"Example 2: Load from SmoQyDQMC and run SmoQyDEAC","text":"","category":"section"},{"location":"examples/SmoQyDQMC/","page":"Example 2: Load from SmoQyDQMC and run SmoQyDEAC","title":"Example 2: Load from SmoQyDQMC and run SmoQyDEAC","text":"Usage:","category":"page"},{"location":"examples/SmoQyDQMC/","page":"Example 2: Load from SmoQyDQMC and run SmoQyDEAC","title":"Example 2: Load from SmoQyDQMC and run SmoQyDEAC","text":"$ julia --threads=auto SmoQyDQMC.jl","category":"page"},{"location":"examples/SmoQyDQMC/","page":"Example 2: Load from SmoQyDQMC and run SmoQyDEAC","title":"Example 2: Load from SmoQyDQMC and run SmoQyDEAC","text":"SmoQyDEAC uses multithreading for parallelizing runs. Multithreading it recommended.   --threads=auto will run a thread for each core available, or 2x for hyperthreading cores","category":"page"},{"location":"examples/SmoQyDQMC/","page":"Example 2: Load from SmoQyDQMC and run SmoQyDEAC","title":"Example 2: Load from SmoQyDQMC and run SmoQyDEAC","text":"In this example we explicitly load output from SmoQyDQMC. After running a simulation with SmoQyDQMC you will need to use the correlation_bins_to_csv method for the desired correlation function prior to using the loading script.","category":"page"},{"location":"examples/SmoQyDQMC/","page":"Example 2: Load from SmoQyDQMC and run SmoQyDEAC","title":"Example 2: Load from SmoQyDQMC and run SmoQyDEAC","text":"This example utilizes the script SmoQyDQMCloader.jl to parse SmoQyDQMC csv files. This script may be moved to another repository at a future date.","category":"page"},{"location":"examples/SmoQyDQMC/","page":"Example 2: Load from SmoQyDQMC and run SmoQyDEAC","title":"Example 2: Load from SmoQyDQMC and run SmoQyDEAC","text":"# First we import our SmoQyDQMC csv parser and needed packages for the example\ninclude(\"SmoQyDQMCloader.jl\")\nusing FileIO\nusing SmoQyDEAC","category":"page"},{"location":"examples/SmoQyDQMC/","page":"Example 2: Load from SmoQyDQMC and run SmoQyDEAC","title":"Example 2: Load from SmoQyDQMC and run SmoQyDEAC","text":"Create directory for outputs","category":"page"},{"location":"examples/SmoQyDQMC/","page":"Example 2: Load from SmoQyDQMC and run SmoQyDEAC","title":"Example 2: Load from SmoQyDQMC and run SmoQyDEAC","text":"output_directory = \"SmoQyDQMC_DEAC_Out/\";\nmkpath(output_directory);\nnothing #hide","category":"page"},{"location":"examples/SmoQyDQMC/","page":"Example 2: Load from SmoQyDQMC and run SmoQyDEAC","title":"Example 2: Load from SmoQyDQMC and run SmoQyDEAC","text":"Load data from fermion greens correlation functions This puts real in the format real[\"ORBITAL\\_ID\\_1\",\"ORBITAL\\_ID\\_2\",\"TAU\",\"K\\_1\",\"K\\_2\",\"K\\_3\",\"BIN\",\"PID\"]`","category":"page"},{"location":"examples/SmoQyDQMC/","page":"Example 2: Load from SmoQyDQMC and run SmoQyDEAC","title":"Example 2: Load from SmoQyDQMC and run SmoQyDEAC","text":"# This example was from a 1D Holstein run with β = 20.0,\n#   ORBITAL\\_ID\\_1 ∈ {1},\n#  ORBITAL\\_ID\\_2 ∈ {1},\n#  TAU          ∈ {0.0,Δτ,...,β-Δτ,β} for Nτ = 201,\n#  Kx           ∈ {1,...,32},\n#  Ky           ∈ {1},\n#  Kz           ∈ {1},\n#  Bin          ∈ {1,...,Nbin} for Nbin = 100,\n#  PID          ∈ {1},\n#\n# Some dimensions are 1 deep. They are kept to ensure generality.\n#\n# See the [`SmoQyDQMCloader.jl`](https://github.com/SmoQySuite/SmoQyDEAC.jl/blob/main/scripts/SmoQyDQMCloader.jl) file for more information\ninput_directory = \"SmoQyDQMC_sim-1/\"\n\ndims,real,image,sgnr,sgni,β = load_from_SmoQyDQMC(simulationfolder=input_directory,\n                                                correlation=\"greens\",\n                                                space=\"momentum\",\n                                                type=\"time_displaced\",bin=true);\n# dims is a dictionary which tells you what each dimension corresponds to.\nprintln(dims)","category":"page"},{"location":"examples/SmoQyDQMC/","page":"Example 2: Load from SmoQyDQMC and run SmoQyDEAC","title":"Example 2: Load from SmoQyDQMC and run SmoQyDEAC","text":"Eliminate unnecessary dimensions","category":"page"},{"location":"examples/SmoQyDQMC/","page":"Example 2: Load from SmoQyDQMC and run SmoQyDEAC","title":"Example 2: Load from SmoQyDQMC and run SmoQyDEAC","text":"Gτ = real[1,1,:,:,1,1,:,1];\nprintln(size(Gτ))","category":"page"},{"location":"examples/SmoQyDQMC/","page":"Example 2: Load from SmoQyDQMC and run SmoQyDEAC","title":"Example 2: Load from SmoQyDQMC and run SmoQyDEAC","text":"Set parameters for DEAC","category":"page"},{"location":"examples/SmoQyDQMC/","page":"Example 2: Load from SmoQyDQMC and run SmoQyDEAC","title":"Example 2: Load from SmoQyDQMC and run SmoQyDEAC","text":"τs = collect(LinRange(0.0,β,size(Gτ,1)))\nNkx = size(Gτ,2)\nnumber_of_bins = 2;\nruns_per_bin = 10 ;\ncheckpoint_file = joinpath(output_directory,\"DEAC_checkpoint.jld2\");\nnω = 401;\nωmin = -10.;\nωmax = 10.;\nωs = collect(LinRange(ωmin,ωmax,nω));\nnothing #hide","category":"page"},{"location":"examples/SmoQyDQMC/","page":"Example 2: Load from SmoQyDQMC and run SmoQyDEAC","title":"Example 2: Load from SmoQyDQMC and run SmoQyDEAC","text":"Run DEAC over all k points in the x direction. For speed in this example I run 1:1 instead of 1:Nkx","category":"page"},{"location":"examples/SmoQyDQMC/","page":"Example 2: Load from SmoQyDQMC and run SmoQyDEAC","title":"Example 2: Load from SmoQyDQMC and run SmoQyDEAC","text":"for kx in 1:1 # 1:Nkx\n    output_file = joinpath(output_directory, string(kx) * \".jld2\");\n    # put in [bins,τ] shape\n    Gτ_temp = Matrix{Float64}(Gτ[:,kx,:]');\n    deac_dict = DEAC_Binned(\n        Gτ_temp,\n        β,\n        τs,\n        ωs,\n        \"time_fermionic\",\n        number_of_bins,\n        runs_per_bin,\n        output_file,\n        checkpoint_file;\n        fitness = [1.5,1.0],\n        find_fitness_floor = false,\n        number_of_generations = 20000,\n        verbose = true\n    )\nend","category":"page"},{"location":"examples/SmoQyDQMC/","page":"Example 2: Load from SmoQyDQMC and run SmoQyDEAC","title":"Example 2: Load from SmoQyDQMC and run SmoQyDEAC","text":"Note, these did not converge to a fitness of 1.0 within 20,000 generations. The number of generations is limited for speed when running this example.","category":"page"},{"location":"examples/SmoQyDQMC/","page":"Example 2: Load from SmoQyDQMC and run SmoQyDEAC","title":"Example 2: Load from SmoQyDQMC and run SmoQyDEAC","text":"","category":"page"},{"location":"examples/SmoQyDQMC/","page":"Example 2: Load from SmoQyDQMC and run SmoQyDEAC","title":"Example 2: Load from SmoQyDQMC and run SmoQyDEAC","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/user_mutation/#Example-3:-User-Mutation","page":"Example 3: User Mutation","title":"Example 3: User Mutation","text":"","category":"section"},{"location":"examples/user_mutation/","page":"Example 3: User Mutation","title":"Example 3: User Mutation","text":"Usage:","category":"page"},{"location":"examples/user_mutation/","page":"Example 3: User Mutation","title":"Example 3: User Mutation","text":"$ julia --threads=auto user_mutation.jl","category":"page"},{"location":"examples/user_mutation/","page":"Example 3: User Mutation","title":"Example 3: User Mutation","text":"SmoQyDEAC uses multithreading for parallelizing runs. Multithreading it recommended.   –threads=auto will run a thread for each core available, or 2x for hyperthreading cores","category":"page"},{"location":"examples/user_mutation/","page":"Example 3: User Mutation","title":"Example 3: User Mutation","text":"In this example we will show how to add an additional user-defined mutation to the DEAC base algorithm","category":"page"},{"location":"examples/user_mutation/","page":"Example 3: User Mutation","title":"Example 3: User Mutation","text":"# First we import all required packages\nusing SmoQyDEAC\nusing FileIO\nusing Statistics\nusing LoopVectorization\nusing Random","category":"page"},{"location":"examples/user_mutation/","page":"Example 3: User Mutation","title":"Example 3: User Mutation","text":"We now load the data provided in our source file. This is the same as example 1, but we are just loading the binned τ data.","category":"page"},{"location":"examples/user_mutation/","page":"Example 3: User Mutation","title":"Example 3: User Mutation","text":"loadfile = \"greens.jld2\";\ninput_dictionary = load(loadfile);\nGτ_bin =  input_dictionary[\"Gτ\"];\nτs = collect(input_dictionary[\"τs\"]);\nβ = τs[end];\nnothing #hide","category":"page"},{"location":"examples/user_mutation/","page":"Example 3: User Mutation","title":"Example 3: User Mutation","text":"Make an output folder for checkpoint file and output file","category":"page"},{"location":"examples/user_mutation/","page":"Example 3: User Mutation","title":"Example 3: User Mutation","text":"output_directory = \"user_mutation_output/\";\nmkpath(output_directory);\nnothing #hide","category":"page"},{"location":"examples/user_mutation/","page":"Example 3: User Mutation","title":"Example 3: User Mutation","text":"Define necessary parameters for the DEAC run. Typically you will want at least 1,000 for numberofbins * runsperbin. For speed's sake we only do 2*5 in this example.","category":"page"},{"location":"examples/user_mutation/","page":"Example 3: User Mutation","title":"Example 3: User Mutation","text":"number_of_bins = 2;\nruns_per_bin = 5 ;\noutput_file = joinpath(output_directory, \"user_mutation_out.jld2\");\ncheckpoint_file = joinpath(output_directory,\"DEAC_checkpoint.jld2\");\nnω = 401;\nωmin = -10.;\nωmax = 10.;\nωs = collect(LinRange(ωmin,ωmax,nω));\nnothing #hide","category":"page"},{"location":"examples/user_mutation/","page":"Example 3: User Mutation","title":"Example 3: User Mutation","text":"Set optional parameters","category":"page"},{"location":"examples/user_mutation/","page":"Example 3: User Mutation","title":"Example 3: User Mutation","text":"base_seed = 1000000;\nkeep_bin_data = false;\nnothing #hide","category":"page"},{"location":"examples/user_mutation/","page":"Example 3: User Mutation","title":"Example 3: User Mutation","text":"Define an additional mutation function which takes two populations of [1:nω,1:n_population] size and a random number generator. Per Julia convention, the first argument is the one which is updated. For those new to Julia, the \"!\" at the end of the function name means the function will mutate at least one of the arguments. This mutation just puts a slight blur on odd indexed ω values. This is not something I imagine you'd want to do, but, this is a simple example","category":"page"},{"location":"examples/user_mutation/","page":"Example 3: User Mutation","title":"Example 3: User Mutation","text":"function user_mut!(pop_new,pop_old,rng)\n    npop = size(pop_old,2)\n    nω = size(pop_old,1)\n    for ω ∈ 1:nω\n        if (ω%2) == 1\n            pop_new[ω,:] = pop_old[ω,:] .+ 0.05 .* (0.5 .- rand(rng,Float64,npop))\n        else\n            pop_new[ω,:] = pop_old[ω,:]\n        end\n    end\n    return nothing\nend","category":"page"},{"location":"examples/user_mutation/","page":"Example 3: User Mutation","title":"Example 3: User Mutation","text":"Vectorized version of the same function using the LoopVectorization.jl package.","category":"page"},{"location":"examples/user_mutation/","page":"Example 3: User Mutation","title":"Example 3: User Mutation","text":"function user_mut_vec!(pop_new,pop_old,rng)\n    rng_pop = rand(rng,Float64,(size(pop_new,1),size(pop_new,2)))\n    @turbo for pop ∈ axes(pop_new,2), ω ∈ axes(pop_new,1)\n        pop_new[ω,pop] = pop_old[ω,pop] + (0.05 * (ω%2) * (0.5 - rng_pop[ω,pop]))\n    end\n    return nothing\nend","category":"page"},{"location":"examples/user_mutation/","page":"Example 3: User Mutation","title":"Example 3: User Mutation","text":"Now we run DEAC with the additional mutation Note, numberofgenerations is set low for the example's run time","category":"page"},{"location":"examples/user_mutation/","page":"Example 3: User Mutation","title":"Example 3: User Mutation","text":"output_dictionary_τ = DEAC_Binned(\n    Gτ_bin,\n    β,\n    τs,\n    ωs,\n    \"time_fermionic\",\n    number_of_bins,\n    runs_per_bin,\n    output_file,\n    checkpoint_file;\n    base_seed = base_seed,\n    keep_bin_data = keep_bin_data,\n    user_mutation! = user_mut_vec!,\n    fitness = 1.0,\n    find_fitness_floor = false,\n    number_of_generations = 10000,\n    verbose = true\n)","category":"page"},{"location":"examples/user_mutation/","page":"Example 3: User Mutation","title":"Example 3: User Mutation","text":"","category":"page"},{"location":"examples/user_mutation/","page":"Example 3: User Mutation","title":"Example 3: User Mutation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/fermion_greens/#Example-1:-Fermion-Greens-function","page":"Example 1: Fermion Greens function","title":"Example 1: Fermion Greens function","text":"","category":"section"},{"location":"examples/fermion_greens/","page":"Example 1: Fermion Greens function","title":"Example 1: Fermion Greens function","text":"Usage:","category":"page"},{"location":"examples/fermion_greens/","page":"Example 1: Fermion Greens function","title":"Example 1: Fermion Greens function","text":"$ julia --threads=auto fermion_greens.jl","category":"page"},{"location":"examples/fermion_greens/","page":"Example 1: Fermion Greens function","title":"Example 1: Fermion Greens function","text":"SmoQyDEAC uses multithreading for parallelizing runs. Multithreading it recommended.   --threads=auto will run a thread for each core available, or 2x for hyperthreading cores","category":"page"},{"location":"examples/fermion_greens/","page":"Example 1: Fermion Greens function","title":"Example 1: Fermion Greens function","text":"In this example we will take the up-spin electron Green's function output from a Determinant Quantum Monte Carlo run generated via SmoQyDQMC using the Holstein Model. For information on how to load directly from SmoQyDQMC see example 2.","category":"page"},{"location":"examples/fermion_greens/","page":"Example 1: Fermion Greens function","title":"Example 1: Fermion Greens function","text":"We note the convention that the correlation function reported as the Green's Function has ħ=1 and there is no leading negative sign","category":"page"},{"location":"examples/fermion_greens/","page":"Example 1: Fermion Greens function","title":"Example 1: Fermion Greens function","text":"G(kτ)=T_τc_k(τ)c_k^(0)","category":"page"},{"location":"examples/fermion_greens/","page":"Example 1: Fermion Greens function","title":"Example 1: Fermion Greens function","text":"Our relation uses the time fermionic kernel such that","category":"page"},{"location":"examples/fermion_greens/","page":"Example 1: Fermion Greens function","title":"Example 1: Fermion Greens function","text":"G(kτ)=int_-^ dω K(ωτ)A(ω)=int_-^ dω frace^-τω1+e^-ωβA(ω)","category":"page"},{"location":"examples/fermion_greens/","page":"Example 1: Fermion Greens function","title":"Example 1: Fermion Greens function","text":"Since A(ω)=-ℑG(ω)π both negative signs that would normally be in the expression and factors of π cancel.","category":"page"},{"location":"examples/fermion_greens/","page":"Example 1: Fermion Greens function","title":"Example 1: Fermion Greens function","text":"On to the example:","category":"page"},{"location":"examples/fermion_greens/","page":"Example 1: Fermion Greens function","title":"Example 1: Fermion Greens function","text":"# First we import all required packages\nusing SmoQyDEAC\nusing FileIO\nusing Statistics","category":"page"},{"location":"examples/fermion_greens/","page":"Example 1: Fermion Greens function","title":"Example 1: Fermion Greens function","text":"We now load the data provided in our source file.","category":"page"},{"location":"examples/fermion_greens/","page":"Example 1: Fermion Greens function","title":"Example 1: Fermion Greens function","text":"loadfile = \"greens.jld2\";\ninput_dictionary = load(loadfile);\n\nGτ_bin =  input_dictionary[\"Gτ\"];\nGτ_std = mean(Gτ_bin,dims=1)[1,:];\nGτ_err = std(Gτ_bin,dims=1)[1,:];\nGω_bin =  input_dictionary[\"Gω\"];\nGω_std = mean(Gω_bin,dims=1)[1,:];\nGω_err = std(Gω_bin,dims=1)[1,:];\n\nτs = collect(input_dictionary[\"τs\"]); # must be evenly spaced.\nβ = τs[end];\nωₙ = collect(input_dictionary[\"ωns\"]);\nnothing #hide","category":"page"},{"location":"examples/fermion_greens/","page":"Example 1: Fermion Greens function","title":"Example 1: Fermion Greens function","text":"Make an output folder for checkpoint file and output file","category":"page"},{"location":"examples/fermion_greens/","page":"Example 1: Fermion Greens function","title":"Example 1: Fermion Greens function","text":"output_directory = \"fermion_greens_output/\";\nmkpath(output_directory);\nnothing #hide","category":"page"},{"location":"examples/fermion_greens/","page":"Example 1: Fermion Greens function","title":"Example 1: Fermion Greens function","text":"Define necessary parameters for the DEAC run Typically you will want at least 1,000 for number_of_bins * runs_per_bin For speed's sake we only do 2*5 in this example.","category":"page"},{"location":"examples/fermion_greens/","page":"Example 1: Fermion Greens function","title":"Example 1: Fermion Greens function","text":"number_of_bins = 2;\nruns_per_bin = 5 ;\noutput_file = joinpath(output_directory, \"fermion_out.jld2\");\ncheckpoint_file = joinpath(output_directory,\"DEAC_checkpoint.jld2\");\nnω = 401;\nωmin = -10.;\nωmax = 10.;\nωs = collect(LinRange(ωmin,ωmax,nω));\nnothing #hide","category":"page"},{"location":"examples/fermion_greens/","page":"Example 1: Fermion Greens function","title":"Example 1: Fermion Greens function","text":"Set optional parameters","category":"page"},{"location":"examples/fermion_greens/","page":"Example 1: Fermion Greens function","title":"Example 1: Fermion Greens function","text":"base_seed = 1000000;\n# Note, the seed will incement for each run.\n# Starting a new run at 1000020 will have output unique from this run\nkeep_bin_data = true;\n# If true, each bin will have it's data written to the output dictionary\n# Set to false to save disk space","category":"page"},{"location":"examples/fermion_greens/","page":"Example 1: Fermion Greens function","title":"Example 1: Fermion Greens function","text":"Run DEAC Algorithm for binned and unbinned data for τ and ωₙ spaces","category":"page"},{"location":"examples/fermion_greens/","page":"Example 1: Fermion Greens function","title":"Example 1: Fermion Greens function","text":"# Note, number_of_generations should typically be > 100,000 or even 1,000,000.\n# It is set lower to reduce run time in this example.\noutput_dictionary_τ = DEAC_Binned(\n    Gτ_bin,\n    β,\n    τs,\n    ωs,\n    \"time_fermionic\",\n    number_of_bins,\n    runs_per_bin,\n    output_file,\n    checkpoint_file;\n    base_seed = base_seed,\n    keep_bin_data = keep_bin_data,\n    verbose = true\n)\noutput_dictionary_τ_std = DEAC_Std(\n    Gτ_std,\n    Gτ_err,\n    β,\n    τs,\n    ωs,\n    \"time_fermionic\",\n    number_of_bins,\n    runs_per_bin,\n    output_file,\n    checkpoint_file;\n    base_seed = base_seed,\n    find_fitness_floor=false,\n    keep_bin_data = keep_bin_data,\n    number_of_generations = 10000,\n    verbose = true\n)\noutput_dictionary_ωₙ = DEAC_Binned(\n    Gω_bin,\n    β,\n    ωₙ,\n    ωs,\n    \"frequency_fermionic\",\n    number_of_bins,\n    runs_per_bin,\n    output_file,\n    checkpoint_file;\n    base_seed = base_seed,\n    keep_bin_data = keep_bin_data,\n    fitness=1.0,\n    find_fitness_floor=false,\n    number_of_generations = 20000,\n    verbose = true\n)\noutput_dictionary_ωₙ_std = DEAC_Std(\n    Gω_std,\n    Gω_err,\n    β,\n    ωₙ,\n    ωs,\n    \"frequency_fermionic\",\n    number_of_bins,\n    runs_per_bin,\n    output_file,\n    checkpoint_file;\n    base_seed = base_seed,\n    keep_bin_data = keep_bin_data,\n    fitness = 1.0,\n    find_fitness_floor = false,\n    number_of_generations = 20000,\n    verbose = true\n)","category":"page"},{"location":"examples/fermion_greens/","page":"Example 1: Fermion Greens function","title":"Example 1: Fermion Greens function","text":"Accessing output","category":"page"},{"location":"examples/fermion_greens/","page":"Example 1: Fermion Greens function","title":"Example 1: Fermion Greens function","text":"# Spectral function, 2D array size (nω,nFitness)\n# nFitness is the number of fitnesses you set. In this case, 1\nA = output_dictionary_τ[\"A\"];\nfitnesses = output_dictionary_τ[\"fitness\"];\n# Spectral function error, 1D array size (nω)\nA_σ = output_dictionary_τ[\"σ\"];\n# ω grid, 1D array size (nω)\nωs_out = output_dictionary_τ[\"ωs\"];\n# zeroth moment: For fermions it is G(0) + G(β) which should = 1.0. Float64s\nzeroth_calc = output_dictionary_τ[\"zeroth_moment\"];\nzeroth_σ = output_dictionary_τ[\"zeroth_moment_σ\"];\n# Number of average generations to converge, Float64\navg_generations = output_dictionary_τ[\"avg_generations\"];\nnothing #hide","category":"page"},{"location":"examples/fermion_greens/","page":"Example 1: Fermion Greens function","title":"Example 1: Fermion Greens function","text":"Binned information - not available if keep_bin_data=false","category":"page"},{"location":"examples/fermion_greens/","page":"Example 1: Fermion Greens function","title":"Example 1: Fermion Greens function","text":"# Bin data, 2D array size (nω,nbins)\nbin_data = output_dictionary_τ[\"bin_data\"];\n# zeroth moment, 1D array (nbins)\nbin_zeroth = output_dictionary_τ[\"bin_zeroth_moment\"];\n# full eigenvalues - only applies to DEAC_Binned\n# These are the eigenvalues of the covariance matrix.\n# Eigenvectors whose eigenvalues are a factor eigenvalue_ratio_min less than the highest eigenvalue\n# are dropped since not all correlation function inputs are linearly independent\nfull_eigenvalues = output_dictionary_τ[\"full_eigenvalues\"];\nnothing #hide","category":"page"},{"location":"examples/fermion_greens/","page":"Example 1: Fermion Greens function","title":"Example 1: Fermion Greens function","text":"The dictionary will automatically be saved","category":"page"},{"location":"examples/fermion_greens/","page":"Example 1: Fermion Greens function","title":"Example 1: Fermion Greens function","text":"# Example of loading the data from the jld2\ntest_dictionary = FileIO.load(output_file)\n# This is identical to output_dictionary_ωₙ_std","category":"page"},{"location":"examples/fermion_greens/","page":"Example 1: Fermion Greens function","title":"Example 1: Fermion Greens function","text":"","category":"page"},{"location":"examples/fermion_greens/","page":"Example 1: Fermion Greens function","title":"Example 1: Fermion Greens function","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#About-the-Package","page":"Home","title":"About the Package","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SmoQyDEAC.jl utilizes the Differential Evolution for Analytic Continuation algorithm developed by Nathan S. Nichols, Paul Sokol, and Adrian Del Maestro arXiv:2201.04155.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package takes imaginary time or Matsubara frequency correlation functions from condensed matter Monte Carlo simulations and provides the associated spectral function on the real axis. ","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"NOTE: This package is in the experimental phase of development and is not yet published to the Julia General registry.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Open a Julia REPL environment and run the following commands:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]\npkg> add SmoQyDEAC","category":"page"},{"location":"#Running-SmoQyDEAC","page":"Home","title":"Running SmoQyDEAC","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SmoQyDEAC has a simple API interface with a two callable functions DEAC_Binned and DEAC_Std for binned data and data with the standard error, respectively.","category":"page"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DEAC_Binned\nDEAC_Std","category":"page"},{"location":"#SmoQyDEAC.DEAC_Binned","page":"Home","title":"SmoQyDEAC.DEAC_Binned","text":"DEAC_Binned(correlation_function::AbstractMatrix,\n     β::Float64,\n     input_grid::Vector{Float64},\n     out_ωs::Vector{Float64},\n     kernel_type::String,\n     num_bins::Int64,\n     runs_per_bin::Int64,\n     output_file::String,\n     checkpoint_file::String;\n\n     find_fitness_floor::Bool = false,\n     population_size::Int64 = 8,\n     base_seed::Integer = 8675309,\n     number_of_generations::Int64 = 20_000,\n     keep_bin_data = true,\n     autoresume_from_checkpoint = false,\n     verbose::Bool = false,\n     fitness = 1.0,\n     \n     crossover_probability::Float64 = 0.9,\n     self_adapting_crossover_probability::Float64 = 0.1,\n     differential_weight::Float64 = 0.9,\n     self_adapting_differential_weight_probability::Float64 = 0.1,\n     self_adapting_differential_weight::Float64 = 0.9,\n     user_mutation! = nothing,\n     eigenvalue_ratio_min::Float64 = 1e-8\n     )\n\nRuns the DEAC algorithm on data passed in correlation_function using Chi^2 fitting using the eigenvalues of the covariance matrix\n\nArguments\n\ncorrelation_function::AbstractMatrix: Input data in τ/ωₙ space, shape [Bins,τ/ωₙ] \nβ::Float64: Inverse temperature\ninput_grid::Vector{Float64}: Evenly spaced values in τ from 0 to β, including end points\nout_ωs::Vector{Float64}: Evenly spaced energies for AC output\nkernel_type::String: See below for allowable kernels\nnum_bins::Int64: Bins to generate\nruns_per_bin::Int64: Number of runs per bin for statistics\noutput_file::String: File to store output dictionary. jld2 format recommended\ncheckpoint_file::String: File to store checkpoint data. jld2 format recommended\n\nOptional Arguments\n\nfind_fitness_floor::Bool = false: Find the floor for fitness and append value to target fitnesses\npopulation_size::Int64 = 8: DEAC population size. Must be ≥ 6\nbase_seed::Int64 = 8675309: Seed\nnumber_of_generations::Int64 = 100000: Maximum number of mutation loops\nkeep_bin_data::Bool = true: Save binned data or not\nautoresume_from_checkpoint::Bool = false: Resume from checkpoint if possible\nverbose::Bool = false: Print stats per run\nfitness = 1.0: single value or an array of values for χ² fitting\n\nOptional algorithm arguments\n\ncrossover_probability::Float64 = 0.9: Starting likelihood of crossover\nself_adapting_crossover_probability::Float64 = 0.1: Chance of crossover probability changing\ndifferential_weight::Float64 = 0.9: Weight for second and third mutable indices\nself_adapting_differential_weight_probability::Float64 = 0.1: Likelihood of SAD changing\nself_adapting_differential_weight::Float64 = 0.9: SAD\nuser_mutation! = nothing: User passed function to add additional mutation to each iteration. See below for more information\neigenvalue_ratio_min::Float64 = 1e-8: Cutoff to mask out eigenvectors with eigenvalues ≈ 0.0 that may arise due to symmetries in input data\n\nEach run will use its own seed. E.g. if you run 10 bins with 100 runs per bin, you will use seeds base_seed:base_seed+999.  You may increment your base seed by 1000, use another output file name, and generate more statistics later.\n\nOutput\n\nSmoQyDEAC will save a dictionary to the file name passed via the output_file argument. The same dictionary will be returned by the function.\n\nCheckpointing\n\nSmoQyDEAC will periodically save a file named according to the parameter passed incheckpoint_file. JLD2 format is recommended, e.g. a file with the .jld2 extension. After completing every bin this file will be saved. After the last bin is finished the file will be deleted. When autoresume_from_checkpoint=true SmoQyDEAC will attempt to resume from the checkpoint.  If the arguments passed do not match those in the checkpoint the code will exit.\n\n\n\n\n\n","category":"function"},{"location":"#SmoQyDEAC.DEAC_Std","page":"Home","title":"SmoQyDEAC.DEAC_Std","text":"DEAC_Std(correlation_function::AbstractVector,\n     correlation_function_error::AbstractVector,\n     β::Float64,\n     input_grid::Vector{Float64},\n     out_ωs::Vector{Float64},\n     kernel_type::String,\n     num_bins::Int64,\n     runs_per_bin::Int64,\n     output_file::String,\n     checkpoint_file::String;\n\n     find_fitness_floor::Bool=true\n     population_size::Int64=8,\n     base_seed::Integer=8675309,\n     number_of_generations::Int64=20_000,\n     keep_bin_data=true,\n     autoresume_from_checkpoint=false,\n     verbose::Bool=false,\n     \n     fitness = 1.0,\n     crossover_probability::Float64 = 0.9,\n     self_adapting_crossover_probability::Float64 = 0.1,\n     differential_weight::Float64 = 0.9,\n     self_adapting_differential_weight_probability::Float64 = 0.1,\n     self_adapting_differential_weight::Float64 = 0.9,\n     user_mutation! = nothing \n     )\n\nRuns the DEAC algorithm on data passed in correlation_function using Chi^2 fitting from the error passed in by correlation_function_error.\n\nArguments\n\ncorrelation_function::AbstractVector: Input data in τ/ωₙ space \ncorrelation_function_error::AbstractVector: Error associated with input data\nβ::Float64: Inverse temperature\ninput_grid::Vector{Float64}: Evenly spaced values in τ from 0 to β, including end points or ωₙ\nout_ωs::Vector{Float64}: Evenly spaced energies for AC output\nkernel_type::String: See below for allowable kernels\nnum_bins::Int64: Bins to generate\nruns_per_bin::Int64: Number of runs per bin for statistics\noutput_file::String: File to store output dictionary. jld2 format recommended\ncheckpoint_file::String: File to store checkpoint data. jld2 format recommended\n\nOptional Arguments\n\nfind_fitness_floor::Bool = false: Find a reasonable floor for fitness and append that value to target fitnesses.\npopulation_size::Int64 = 8: DEAC population size. Must be ≥ 6\nbase_seed::Int64 = 8675309: Seed\nnumber_of_generations::Int64 = 100000: Maximum number of mutation loops\nkeep_bin_data::Bool = true: Save binned data or not\nautoresume_from_checkpoint::Bool = false: Resume from checkpoint if possible\nverbose::Bool = false: Print stats per run\nfitness = 1.0: single value or an array of values for χ² fitting\n\nOptional algorithm arguments\n\ncrossover_probability::Float64 = 0.9: Starting likelihood of crossover\nself_adapting_crossover_probability::Float64 = 0.1: Chance of crossover probability changing\ndifferential_weight::Float64 = 0.9: Weight for second and third mutable indices\nself_adapting_differential_weight_probability::Float64 = 0.1: Likelihood of SAD changing\nself_adapting_differential_weight::Float64 = 0.9: SAD\nuser_mutation! = nothing: User passed function to add additional mutation to each iteration. See below for more information\n\nEach run will use its own seed. E.g. if you run 10 bins with 100 runs per bin, you will use seeds base_seed:base_seed+999.  You may increment your base seed by 1000, use another output file name, and generate more statistics later.\n\nOutput\n\nSmoQyDEAC will save a dictionary to the file name passed via the output_file argument. The same dictionary will be returned by the function.\n\nCheckpointing\n\nSmoQyDEAC will periodically save a file named according to the parameter passed incheckpoint_file. JLD2 format is recommended, e.g. a file with the .jld2 extension. After completing every bin this file will be saved. After the last bin is finished the file will be deleted. When autoresume_from_checkpoint=true SmoQyDEAC will attempt to resume from the checkpoint.  If the arguments passed do not match those in the checkpoint the code will exit.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"To add additional mutations to the base DEAC algorithm you utilize the user_mutation! functionality. user_mutation! is a user defined function which takes three (3) parameters, (population_new, population_old, rng). The result in population_new is treated as a new trial population, and if the fitness improves for a population, the trial population is stored.","category":"page"},{"location":"","page":"Home","title":"Home","text":"population_new and population_old are of the shape [1:nω, 1:population_size]. Note, there is no guarantee that population_new is a copy of population_old, so the user should update the entire array. See Example 3: User Mutation for an example implementation.","category":"page"},{"location":"#Output","page":"Home","title":"Output","text":"","category":"section"},{"location":"#Default-Keys","page":"Home","title":"Default Keys","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Both API functions return a Dict{String,Any} object as well as save that dictionary to the location specified in the parameter output_file. The dictionary has the following keys","category":"page"},{"location":"","page":"Home","title":"Home","text":"A: 2D array of shape (nomega,nFitness), where nFitness is the number of fitness targets in the run. \nfitness: 1D array with all fitnesses associated with the run in descending order\nσ: The calculated standard error for the run. NOTE: DEAC is non-ergodic, so this does not correspond actual error bars!\nωs: The omega values corresponding to the first dimenson of A.\navg_generations: number of generations to reach lowest target fitness\nruntime: Total run time in seconds\nzeroth_moment: 1D array of the calculated zeroth moments for the reported range of $\\omega$s for each fitness\nzeroth_moment_σ: Standard error for zeroth_moment.\nfull_eigenvalues: Only pertinent for binned data. When finding the eigenbasis for the covariance matrix near-zero eigenvalues may arise due to linear correlations in your data. Those below the value eigenvalueratiomin*maximum(eigenvalues) will be ignored and their eigenvectors not used.","category":"page"},{"location":"#Bin-data","page":"Home","title":"Bin data","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If keep_bin_data==true then the following keys are also in the output dictionary","category":"page"},{"location":"","page":"Home","title":"Home","text":"bin_data: 3D array of size (nomega,nBins,nFitness) with data from each bin.\nbin_zeroth_moment: Same as zeroth_moment but on a bin by bin basis.","category":"page"},{"location":"#Kernels","page":"Home","title":"Kernels","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following are the supported kernels","category":"page"},{"location":"","page":"Home","title":"Home","text":"time_fermionic=frace^-tauomega1+e^-betaomega\ntime_bosonic=frace^-tauomega1-e^-betaomega\ntime_bosonic_symmetric=frac12frace^-tauomega+e^-(beta-tau)omega1-e^-betaomega\ntime_bosonic_symmetric_w=fracomega2frace^-tauomega+e^-(beta-tau)omega1-e^-betaomega\nfrequency_fermionic=frac1iomega_n-omega\nfrequency_bosonic=frac1iomega_n-omega\nfrequency_bosonic_symmetric=frac2 omegaomega_n^2+omega^2","category":"page"},{"location":"#Multithreading","page":"Home","title":"Multithreading","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SmoQyDEAC utilizes Julia's Threads.@threads multithreading capability. To take advantage of this run your code using  $ julia --threads=auto yourscript.jl.  auto will automatically use any available cores or hyperthreads. You can set the value to a fixed number as you wish.","category":"page"},{"location":"#Tips,-tricks-and-caveats","page":"Home","title":"Tips, tricks and caveats","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You will likely never need to adjust any of the Optional Algorithm Arguments from the default. Many are merely initial values and will be updated stochastically early and often in the code.\nThe DEAC algorithm can have edge effects where it places spectral weight on the first or last ω point. This occurs when there is spectral weight just outside of your range of ωs. The solution is simply expanding the range of your output energies.\nFor bosonic correlations SmoQyDEAC returns the spectral function, e.g. mathcalA(omega) not fracmathcalA(omega)omega as some MaxEnt codes do.\nDifferent simulation codes may report correlation functions slightly differently. E.g. for SmoQyDQMC phonon_greens =langle X(tau)X(0)rangle not the actual phonon green's function of -2Omega_0langle X(tau)X(0)rangle. While the negative sign will cancel out by our choice of Kernel, you may need to postprocess the spectral function you recover. In this case mathcalArightarrow dfracmathcalA2Omega_0. ","category":"page"},{"location":"#Funding","page":"Home","title":"Funding","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This work was supported by the U.S. Department of Energy, Office of Science, Office of Basic Energy Sciences, under Award Number DE-SC0022311. N.S.N. was supported by the Argonne Leadership Computing Facility, which is a U.S. Department of Energy Office of Science User Facility operated under contract DE-AC02-06CH11357. ","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you found this library to be useful in the course of academic work, please consider citing us:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@Article{10.21468/SciPostPhysCodeb.39,\n\ttitle={{SmoQyDEAC.jl: A differential evolution package for the analytic continuation of imaginary time correlation functions}},\n\tauthor={James Neuhaus and Nathan S. Nichols and Debshikha Banerjee and Benjamin Cohen-Stead and Thomas A. Maier and Adrian Del Maestro and Steven Johnston},\n\tjournal={SciPost Phys. Codebases},\n\tpages={39},\n\tyear={2024},\n\tpublisher={SciPost},\n\tdoi={10.21468/SciPostPhysCodeb.39},\n\turl={https://scipost.org/10.21468/SciPostPhysCodeb.39},\n}","category":"page"},{"location":"#Publication-List","page":"Home","title":"Publication List","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This sections lists of some of the publications that report results generated using the SmoQyDEAC.jl package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"M. Zhu, L. M. Chinellato, V. Romerio, N. Murai, S. Ohira-Kawamura, C. Balz, Z. Yan, S. Gvasaliya, Y. Kato, C. D. Batista and A. Zheludev. Wannier states and spin supersolid physics in the triangular antiferromagnet K2Co(SeO3)2, npj Quantum Materials 10, 74 (2025).\n\n\n\n","category":"page"},{"location":"#Contact-Us","page":"Home","title":"Contact Us","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For question and comments regarding this package, please email either James Neuhaus at jneuhau1@utk.edu or Professor Steven Johnston at sjohn145@utk.edu.","category":"page"},{"location":"#Publication-List-2","page":"Home","title":"Publication List","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
