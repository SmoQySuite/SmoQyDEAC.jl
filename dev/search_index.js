var documenterSearchIndex = {"docs":
[{"location":"derivations/#Derivations","page":"Derivations","title":"Derivations","text":"","category":"section"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"Here we will derive properties of correlation functions in imaginary time and their spectral functions. If you find an error in this page please report an issue via github or email James Neuhaus. ","category":"page"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"Conventions: hbar=1, for pmmp top signs are for bosonic correlations, bottom signs fermionic","category":"page"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"Causal Matsubara correlation functions are defined such that for operators hatAhatB the correlation function is ","category":"page"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"C_AB(tau -tau)=-langle T_tauA(tau)B(tau)rangle=-Theta(tau-tau)langle A(tau)B(tau)rangle mp Theta(tau-tau)langle B(tau)A(tau)rangle ","category":"page"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"By using translational symmetry we can set tau=0 which we will do going forward.","category":"page"},{"location":"derivations/#Periodicity","page":"Derivations","title":"Periodicity","text":"","category":"section"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"Starting from tau  0 we have","category":"page"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"beginalign*\nC_ABleft(tau0right)=-langle Aleft(tauright)Bleft(0right)rangle=  -frac1ZTrlefte^-beta He^tau HAe^-tau HBright\n=  -frac1ZTrleftBe^-beta He^tau HAe^-tau Hright\n=  -frac1ZTrleftBe^-beta He^tau HAe^-tau Hleft(e^beta He^-beta Hright)right\n=  -frac1ZTrlefte^-beta HBe^-beta He^tau HAe^-tau He^beta Hright\n=  -frac1ZTrlefte^-beta HBe^left(tau-betaright)HAe^-left(tau-betaright)Hright\n=  -langle Bleft(0right)Aleft(tau-betaright)rangle\n=  pmlangle T_tauAleft(tau-betaright)Bleft(0right)rangle\n=  pm C_ABleft(tau-betaright)\nendalign*","category":"page"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"Thus, correlation functions take on the patterns:","category":"page"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"(Image: Cristophe Berthod, https://giamarchi.unige.ch/wp-content/php\\_code/people/christophe.berthod/pdf/Many-body.pdf) Cristophe Berthod","category":"page"},{"location":"derivations/#Reflection-Symmetry","page":"Derivations","title":"Reflection Symmetry","text":"","category":"section"},{"location":"derivations/#Correlation-Functions","page":"Derivations","title":"Correlation Functions","text":"","category":"section"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"Let us look at correlation functions with the operator order flipped","category":"page"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"beginalign*\nC_BAleft(tauright)=  -Thetaleft(tauright)leftlangle Bleft(tauright)Aleft(0right)rightrangle mpThetaleft(-tauright)leftlangle Aleft(0right)Bleft(tauright)rightrangle \n=  -fracThetaleft(tauright)ZTrlefte^-beta He^tau HBe^-tau HArightmpfracThetaleft(-tauright)ZTrlefte^-beta HAe^tau HBe^-tau Hright\n=  -fracThetaleft(tauright)ZTrlefte^-beta He^beta He^-tau HAe^-beta He^tau HBrightmpfracThetaleft(-tauright)ZTrlefte^-beta HAe^tau He^beta He^-beta HBe^-tau Hright\n=  -fracThetaleft(tauright)ZTrlefte^-beta He^beta He^-tau HAe^-beta He^tau HBrightmpfracThetaleft(-tauright)ZTrlefte^-beta HBe^-tau He^-beta HAe^tau He^beta Hright\n=  -fracThetaleft(tauright)ZTrlefte^-beta He^left(beta-tauright)HAe^-left(beta-tauright)He^tau HBrightmpfracThetaleft(-tauright)ZTrlefte^-beta HBe^-left(beta+tauright)HAe^left(beta+tauright)Hright\n=  -Thetaleft(tauright)leftlangle Aleft(beta-tauright)Bleft(0right)rightrangle mpThetaleft(-tauright)leftlangle Bleft(-beta-tauright)Aleft(0right)rightrangle \n=  pm C_ABleft(beta-tauright)\nendalign*","category":"page"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"It follows that in the case where the two operators are the same, B=A, this expression becomes C_AAleft(tauright)=pm C_AAleft(beta-tauright). Thus, a symmetrized/antisymmetrized kernel is needed.","category":"page"},{"location":"derivations/#Spectral-Functions","page":"Derivations","title":"Spectral Functions","text":"","category":"section"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"We define our spectral function as","category":"page"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"beginalign*\nrho_ABleft(omegaright)=  frac2piZleft(1mp e^-betaomegaright)sum_nme^-beta E_nleftlangle mlefthatArightnrightrangle leftlangle nlefthatBrightmrightrangle deltaleft(omega+E_m-E_nright)\nendalign*","category":"page"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"We will swap indices and then take omegarightarrow -omega","category":"page"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"beginalign*\nrho_ABleft(omegaright)=  frac2piZleft(1mp e^-betaomegaright)sum_nme^-beta E_nleftlangle mlefthatArightnrightrangle leftlangle nlefthatBrightmrightrangle deltaleft(omega+E_m-E_nright)\n=  -frac2piZleft(1mp e^-betaomegaright)sum_nme^-beta E_mleftlangle nlefthatBrightmrightrangle leftlangle mlefthatArightnrightrangle deltaleft(omega+E_n-E_mright)\n=  -rho_BAleft(-omegaright)\nendalign*","category":"page"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"For both fermions and bosons we pick up a minus sign for two different reasons: bosons because of the inverted Bose factor 1-e^-betaomegarightarrow e^-betaomega-1 and the fermion case's sign flips from the operator order flip. ","category":"page"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"In the case of A=B we get rho(omega)=-rho(omega)","category":"page"},{"location":"derivations/#Kernels-for-\\tau\\rightarrow\\omega","page":"Derivations","title":"Kernels for taurightarrowomega","text":"","category":"section"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"Spectral functions are defined in such a way as to reflect what is measured in experiment. For example, let's look at the correlation function which is also the electron Green's function","category":"page"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"beginalign*\nG_alphabetaleft(tauright)=  -leftlangle T_taua_alphaleft(tauright)a_beta^daggerleft(0right)rightrangle \nendalign*","category":"page"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"This relates back to the spectral function for the electron occupation energies through the relation","category":"page"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"beginalign*\nGleft(mathbfksigmatau0right)=  -leftlangle c_mathbfksigmaleft(tauright)c_mathbfksigma^daggerleft(0right)rightrangle \n=  -frac1Zsum_nleftlangle nlefte^-beta He^tau Hc_mathbfksigmae^-tau Hc_mathbfksigma^daggerrightnrightrangle \n=  -frac1Zsum_ne^-beta E_ne^tau E_nleftlangle nleftc_mathbfksigmae^-tau Hc_mathbfksigma^daggerrightnrightrangle \n=  -frac1Zsum_mne^-beta E_ne^tauleft(E_n-E_mright)leftlangle nleftc_mathbfksigmarightmrightrangle leftlangle mleftc_mathbfksigma^daggerrightnrightrangle \n=  -frac1Zsum_mne^-beta E_ne^tauleft(E_n-E_mright)leftleftlangle mleftc_mathbfksigma^daggerrightnrightrangle right^2\n=  -int_-infty^inftyfracdomegapifrace^-omegatau1+e^-betaomegaIm Gleft(mathbfksigmaomegaright)\n=  int_-infty^infty domega frace^-omegatau1+e^-betaomegaAleft(mathbfksigmaomegaright)\nendalign*","category":"page"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"This gives us the fermionic kernel of frace^-omegatau1+e^-betaomega. Doing the same treatment for antisymmetric fermionic correlations, bosonic correlations, and symmetric bosonic correlations we get the following kernels:","category":"page"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"beginalign*\nK_fermionleft(omegatauright)=  frace^-tauomega1+e^-betaomega\nK_fermionantisymleft(omegatauright)=  frac12frace^-tauomega-e^-left(beta-tauright)omega1+e^-betaomega\nK_bosonasymleft(omegatauright)=  frace^-tauomega1-e^-betaomega\nK_bosonsymleft(omegatauright)=  frace^-tauomega+e^-left(beta-tauright)1-e^-betaomega\nendalign*","category":"page"},{"location":"derivations/#Bosonic-Kernel-Modifications-for-AC-methods","page":"Derivations","title":"Bosonic Kernel Modifications for AC methods","text":"","category":"section"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"For kernel functions odd about omega=0 most AC codes will pull a factor of omega into the kernel. This makes the kernel analytic on the entire omega line but AC will give you fracrho(omega)omega. Some codes will return this value. DEAC.jl handles this in the back end and reports only rho(omega).","category":"page"},{"location":"derivations/#Normalization","page":"Derivations","title":"Normalization","text":"","category":"section"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"For the fermionic non-symmetric case it is simple to tell the zeroth moment of the spectral function","category":"page"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"beginalign*\nC_ABleft(0right)+C_ABleft(betaright)=  int domega Aleft(omegaright)frace^-0omega+e^-betaomega1+e^-betaomega\nC_ABleft(0right)+C_ABleft(betaright)=  int domega Aleft(omegaright)\nendalign*","category":"page"},{"location":"derivations/","page":"Derivations","title":"Derivations","text":"For any others there is no obvious way to derive the zeroth moment. ","category":"page"},{"location":"examples/fermion_greens/","page":"Examples","title":"Examples","text":"EditURL = \"fermion_greens.jl\"","category":"page"},{"location":"examples/fermion_greens/#Example-1:-Fermion-Greens-function","page":"Examples","title":"Example 1: Fermion Greens function","text":"","category":"section"},{"location":"examples/fermion_greens/","page":"Examples","title":"Examples","text":"Usage:","category":"page"},{"location":"examples/fermion_greens/","page":"Examples","title":"Examples","text":"$ julia --threads=auto fermion_greens.jl","category":"page"},{"location":"examples/fermion_greens/","page":"Examples","title":"Examples","text":"SmoQyDEAC uses multithreading for parallelizing runs. Multithreading it recommended.   –threads=auto will run a thread for each core available, or 2x for hyperthreading cores","category":"page"},{"location":"examples/fermion_greens/","page":"Examples","title":"Examples","text":"In this example we will take the up-spin electron Green's function output from a Determinant Quantum Monte Carlo run generated via SmoQyDQMC using the Holstein Model.","category":"page"},{"location":"examples/fermion_greens/","page":"Examples","title":"Examples","text":"We note the convention that the correlation function reported as the Green's Function has ħ=1 and there is no leading negative sign","category":"page"},{"location":"examples/fermion_greens/","page":"Examples","title":"Examples","text":"G(kτ)=T_τc_k(τ)c_k^(0)","category":"page"},{"location":"examples/fermion_greens/","page":"Examples","title":"Examples","text":"Our relation uses the time fermionic kernel such that","category":"page"},{"location":"examples/fermion_greens/","page":"Examples","title":"Examples","text":"G(kτ)=int_-^ dω K(ωτ)A(ω)=int_-^ dω frace^-τω1+e^-ωβA(ω)","category":"page"},{"location":"examples/fermion_greens/","page":"Examples","title":"Examples","text":"Since A(ω)=-ℑG(ω)π both negative signs that would normally be in the expression and factors of π cancel.","category":"page"},{"location":"examples/fermion_greens/","page":"Examples","title":"Examples","text":"On to the example:","category":"page"},{"location":"examples/fermion_greens/","page":"Examples","title":"Examples","text":"# First we import all required packages\nusing SmoQyDEAC\nusing FileIO","category":"page"},{"location":"examples/fermion_greens/","page":"Examples","title":"Examples","text":"We now load the data provided in our source file.","category":"page"},{"location":"examples/fermion_greens/","page":"Examples","title":"Examples","text":"loadfile = joinpath(pkgdir(SmoQyDEAC), \"docs/src/examples/greens.jld2\")\ninput_dictionary = load(loadfile)\n\nG_std = input_dictionary[\"G_std\"];\nG_error = input_dictionary[\"G_err\"];\nG_bin =  input_dictionary[\"G_bin\"];\nτs = input_dictionary[\"τs\"]; # must be evenly spaced.\nβ = input_dictionary[\"β\"];\nnothing #hide","category":"page"},{"location":"examples/fermion_greens/","page":"Examples","title":"Examples","text":"Make an output folder for checkpoint file and output file","category":"page"},{"location":"examples/fermion_greens/","page":"Examples","title":"Examples","text":"output_directory = \"fermion_greens_output/\";\ntry\n    mkdir(output_directory);\ncatch\nend","category":"page"},{"location":"examples/fermion_greens/","page":"Examples","title":"Examples","text":"Define necessary parameters for the DEAC run Typically you will want at least 1,000 for numberofbins * runsperbin For speed's sake we only do 2*1 in this example.","category":"page"},{"location":"examples/fermion_greens/","page":"Examples","title":"Examples","text":"number_of_bins = 2;\nruns_per_bin = 1 ;\noutput_file = joinpath(output_directory, \"fermion_out.jld2\");\ncheckpoint_directory = output_directory;\nnω = 401;\nωmin = -10.;\nωmax = 10.;\nωs = collect(LinRange(ωmin,ωmax,nω));\nnothing #hide","category":"page"},{"location":"examples/fermion_greens/","page":"Examples","title":"Examples","text":"Set optional parameters","category":"page"},{"location":"examples/fermion_greens/","page":"Examples","title":"Examples","text":"base_seed = 1000000;\n# Note, the seed will incement for each run.\n# Starting a new run at 1000002 will have output unique from this run\nkeep_bin_data = true;\n# If true, each bin will have it's data written to the output dictionary\n# Set to false to save disk space","category":"page"},{"location":"examples/fermion_greens/","page":"Examples","title":"Examples","text":"Run DEAC Algorithm for binned and unbinned","category":"page"},{"location":"examples/fermion_greens/","page":"Examples","title":"Examples","text":"output_dictionary = DEAC_Binned(G_bin,β,τs,ωs,\"time_fermionic\",number_of_bins,runs_per_bin,output_file,\n                         checkpoint_directory,base_seed=base_seed,keep_bin_data=keep_bin_data)\noutput_dictionary_std = DEAC_Std(G_std,G_error,β,τs,ωs,\"time_fermionic\",number_of_bins,runs_per_bin,output_file,\n                         checkpoint_directory,base_seed=base_seed,keep_bin_data=keep_bin_data)","category":"page"},{"location":"examples/fermion_greens/","page":"Examples","title":"Examples","text":"Accessing output","category":"page"},{"location":"examples/fermion_greens/","page":"Examples","title":"Examples","text":"# Spectral function, 1D array size (nω)\nA = output_dictionary[\"A\"];\n# Spectral function error, 1D array size (nω)\nA_σ = output_dictionary[\"σ\"];\n# ω grid, 1D array size (nω)\nωs_out = output_dictionary[\"ωs\"];\n# zeroth moment: For fermions it is G(0) + G(β) which should = 1.0. Float64s\nzeroth_calc = output_dictionary[\"zeroth_moment\"];\nzeroth_σ = output_dictionary[\"zeroth_moment_σ\"];\n# Number of average generations to converge, Float64\navg_generations = output_dictionary[\"avg_generations\"];\nnothing #hide","category":"page"},{"location":"examples/fermion_greens/","page":"Examples","title":"Examples","text":"Binned information - not available if keep_bin_data=false","category":"page"},{"location":"examples/fermion_greens/","page":"Examples","title":"Examples","text":"# Bin data, 2D array size (nω,nbins)\nbin_data = output_dictionary[\"bin_data\"];\n# zeroth moment, 1D array (nbins)\nbin_zeroth = output_dictionary[\"bin_zeroth_moment\"];\nnothing #hide","category":"page"},{"location":"examples/fermion_greens/","page":"Examples","title":"Examples","text":"The dictionary will automatically be saved","category":"page"},{"location":"examples/fermion_greens/","page":"Examples","title":"Examples","text":"# Example of loading the data from the jld2\ntest_dictionary = FileIO.load(output_file)","category":"page"},{"location":"examples/fermion_greens/","page":"Examples","title":"Examples","text":"This is identical to output_dictionary","category":"page"},{"location":"examples/fermion_greens/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"examples/fermion_greens/","page":"Examples","title":"Examples","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#About-the-Package","page":"Home","title":"About the Package","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SmoQyDEAC utilizes the Differential Evolution for Analytic Continuation algorithm developed by Nathan S. Nichols, Paul Sokol, and Adrian Del Maestro arXiv:2201.04155.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package takes imaginary time or Matsubara frequency correlation functions from condensed matter Monte Carlo simulations and provides the associated spectral function on the real axis. ","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"NOTE: This package is in the experimental phase of development and is not yet published to the Julia General registry.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Open a Julia REPL environment and run the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"] dev https://github.com/SmoQySuite/SmoQyDEAC.jl.git","category":"page"},{"location":"","page":"Home","title":"Home","text":"This command clones the SmoQyDEAC.jl repository to the hidden directory .julia/dev that exists in the same directory where Julia is installed.","category":"page"},{"location":"#Running-SmoQyDEAC","page":"Home","title":"Running SmoQyDEAC","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SmoQyDEAC has a simple API interface with a single callable function DEAC.","category":"page"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DEAC_Binned\nDEAC_Std","category":"page"},{"location":"","page":"Home","title":"Home","text":"DEAC_Binned","category":"page"},{"location":"#SmoQyDEAC.DEAC_Binned","page":"Home","title":"SmoQyDEAC.DEAC_Binned","text":"DEAC_Binned(correlation_function::AbstractMatrix,\n     β::Float64,\n     input_grid::Vector{Float64},\n     out_ωs::Vector{Float64},\n     kernel_type::String,\n     num_bins::Int64,\n     runs_per_bin::Int64,\n     output_file::String,\n     checkpoint_directory::String;\n\n     find_ideal_fitness::Bool=true\n     population_size::Int64=8,\n     base_seed::Integer=8675309,\n     number_of_generations::Int64=1000000,\n     keep_bin_data=true,\n     autoresume_from_checkpoint=false,\n     verbose::Bool=false,\n     stop_minimum_fitness::Float64=1.0,\n     \n     crossover_probability::Float64=0.9,\n     self_adapting_crossover_probability::Float64=0.1,\n     differential_weight::Float64=0.9,\n     self_adapting_differential_weight_probability::Float64=0.1,\n     self_adapting_differential_weight::Float64=0.9,\n     )\n\nRuns the DEAC algorithm on data passed in correlation_function using Chi^2 fitting from the error passed in by correlation_function_error.\n\nArguments\n\ncorrelation_function::AbstractVector: Input data in τ space \ncorrelation_function_error::AbstractVector: Error associated with input data\nβ::Float64: Inverse temperature\ninput_grid::Vector{Float64}: Evenly spaced values in τ from 0 to β, including end points\nout_ωs::Vector{Float64}: Energies for AC output\nkernel_type::String: See below for allowable kernels\nnum_bins::Int64: Bins to generate\nruns_per_bin::Int64: Number of runs per bin for statistics\noutput_file::String: File to store output dictionary. jld2 format recommended\ncheckpoint_directory::String: Directory to store checkpoint data. \n\nOptional Arguments\n\nfind_ideal_fitness::Bool=true: Use ideal fitness finder\npopulation_size::Int64=8: DEAC population size. Must be ≥ 6\nbase_seed::Int64=8675309: Seed\nnumber_of_generations::Int64=100000: Maximum number of mutation loops\nkeep_bin_data::Bool=true: Save binned data or not\nautoresume_from_checkpoint::Bool=false: Resume from checkpoint if possible\nverbose::Bool=false: Print stats per run\nstop_minimum_fitness::Float64=1.0: Value below which fit is considered good, only applies if find_ideal_fitness=false\n\nOptional algorithm arguments\n\ncrossover_probability::Float64=0.9: Starting likelihood of crossover\nself_adapting_crossover_probability::Float64=0.1: Chance of crossover probability changing\ndifferential_weight::Float64=0.9: Weight for second and third mutable indices\nself_adapting_differential_weight_probability::Float64=0.1: Likelihood of SAD changing\nself_adapting_differential_weight::Float64=0.9: SAD\nW_ratio_max::Float64=1.0e6: Χ² ~ 1.0/σ², this parameter prevents [near] singularities for very small σ \nbootstrap_bins::Int=0: The algorithm requires more bins than τ steps. We use bootstrapping to get 5 * nτ bins by default. User may set this higher \n\nEach run will use its own seed. E.g. if you run 10 bins with 100 runs per bin, you will use seeds base_seed:base_seed+999.  You may increment your base seed by 1000, use another output file name, and generate more statistics later.\n\nOutput\n\nSmoQyDEAC will save a dictionary to the file name passed via the output_file argument. The same dictionary will be returned by the function.\n\nCheckpointing\n\nSmoQyDEAC will place a file named DEAC_checkpoint.jld2 in the directory passed in checkpoint_directory. After completing every bin this file will be saved. After the last bin is finished the file will be deleted. When autoresume_from_checkpoint=true SmoQyDEAC will attempt to resume from the checkpoint.  If the arguments passed do not match those in the checkpoint the code will exit. \n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"DEAC_Std","category":"page"},{"location":"#SmoQyDEAC.DEAC_Std","page":"Home","title":"SmoQyDEAC.DEAC_Std","text":"DEAC_Std(correlation_function::AbstractVector,\n     correlation_function_error::AbstractVector,\n     β::Float64,\n     input_grid::Vector{Float64},\n     out_ωs::Vector{Float64},\n     kernel_type::String,\n     num_bins::Int64,\n     runs_per_bin::Int64,\n     output_file::String,\n     checkpoint_directory::String;\n\n     find_ideal_fitness::Bool=true\n     population_size::Int64=8,\n     base_seed::Integer=8675309,\n     number_of_generations::Int64=1000000,\n     keep_bin_data=true,\n     autoresume_from_checkpoint=false,\n     verbose::Bool=false,\n     \n     stop_minimum_fitness::Float64=1.0,\n     crossover_probability::Float64=0.9,\n     self_adapting_crossover_probability::Float64=0.1,\n     differential_weight::Float64=0.9,\n     self_adapting_differential_weight_probability::Float64=0.1,\n     self_adapting_differential_weight::Float64=0.9)\n\nRuns the DEAC algorithm on data passed in correlation_function using Chi^2 fitting from the error passed in by correlation_function_error.\n\nArguments\n\ncorrelation_function::AbstractVector: Input data in τ space \ncorrelation_function_error::AbstractVector: Error associated with input data\nβ::Float64: Inverse temperature\ninput_grid::Vector{Float64}: Evenly spaced values in τ from 0 to β, including end points\nout_ωs::Vector{Float64}: Energies for AC output\nkernel_type::String: See below for allowable kernels\nnum_bins::Int64: Bins to generate\nruns_per_bin::Int64: Number of runs per bin for statistics\noutput_file::String: File to store output dictionary. jld2 format recommended\ncheckpoint_directory::String: Directory to store checkpoint data. \n\nOptional Arguments\n\nfind_ideal_fitness::Bool=true: Use ideal fitness finder\npopulation_size::Int64=8: DEAC population size. Must be ≥ 6\nbase_seed::Int64=8675309: Seed\nnumber_of_generations::Int64=100000: Maximum number of mutation loops\nkeep_bin_data::Bool=true: Save binned data or not\nautoresume_from_checkpoint::Bool=false: Resume from checkpoint if possible\nverbose::Bool=false: Print stats per run\nstop_minimum_fitness::Float64=1.0: Value below which fit is considered good, only applies if find_ideal_fitness=false\n\nOptional algorithm arguments\n\ncrossover_probability::Float64=0.9: Starting likelihood of crossover\nself_adapting_crossover_probability::Float64=0.1: Chance of crossover probability changing\ndifferential_weight::Float64=0.9: Weight for second and third mutable indices\nself_adapting_differential_weight_probability::Float64=0.1: Likelihood of SAD changing\nself_adapting_differential_weight::Float64=0.9: SAD\n\nEach run will use its own seed. E.g. if you run 10 bins with 100 runs per bin, you will use seeds base_seed:base_seed+999.  You may increment your base seed by 1000, use another output file name, and generate more statistics later.\n\nOutput\n\nSmoQyDEAC will save a dictionary to the file name passed via the output_file argument. The same dictionary will be returned by the function.\n\nCheckpointing\n\nSmoQyDEAC will place a file named DEAC_checkpoint.jld2 in the directory passed in checkpoint_directory. After completing every bin this file will be saved. After the last bin is finished the file will be deleted. When autoresume_from_checkpoint=true SmoQyDEAC will attempt to resume from the checkpoint.  If the arguments passed do not match those in the checkpoint the code will exit.\n\n\n\n\n\n","category":"function"},{"location":"#Kernels","page":"Home","title":"Kernels","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following are the supported kernels","category":"page"},{"location":"","page":"Home","title":"Home","text":"time_fermionic=frace^-tauomega1+e^-betaomega\ntime_bosonic=frace^-tauomega1-e^-betaomega\ntime_bosonic_symmetric=frace^-tauomega+e^-(beta-tau)omega1-e^-betaomega\nfrequency_fermionic=frac10iomega_n-omega\nfrequency_bosonic=frac10iomega_n-omega\nfrequency_bosonic_symmetric=frac20 omegaomega_n^2+omega^2","category":"page"},{"location":"#Multithreading","page":"Home","title":"Multithreading","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SmoQyDEAC utilizes Julia's Threads.@threads multithreading capability. To take advantage of this run your code using  $ julia --threads=auto yourscript.jl auto will automatically use any available cores or hyperthreads. You can set the value to a fixed number as you wish.","category":"page"},{"location":"#Tips,-tricks-and-caveats","page":"Home","title":"Tips, tricks and caveats","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You will likely never need to adjust any of the Optional Algorithm Arguments from the default. Many are merely initial values and will be updated stochastically early and often in the code.\nThe DEAC algorithm can have edge effects where it places spectral weight on the first or last ω point. This occurs when there is spectral weight just outside of your range of ωs. The solution is simply expanding the range of your output energies.\nFor bosonic correlations SmoQyDEAC returns the spectral function, e.g. B(omega) not fracB(omega)omega as some MaxEnt codes do.\nDifferent simulation codes may report correlation functions slightly differently. E.g. for SmoQyDQMC phonon_greens =langle X(tau)X(0)rangle not the actual phonon green's function of -2Omega_0langle X(tau)X(0)rangle. While the negative sign will cancel out by our choice of Kernel, you may need to postprocess the spectral function you recover. In this case Brightarrow dfracB2Omega_0","category":"page"}]
}
